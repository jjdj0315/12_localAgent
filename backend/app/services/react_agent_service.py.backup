"""
ReAct Agent Service

Implements the ReAct (Reasoning and Acting) pattern for tool-using AI agents.
Per FR-062: Thought â†’ Action â†’ Observation loop, max 5 iterations.
Per FR-063: Tool execution safety (30s timeout, sandboxing).
Per FR-065: Transparent error handling.
Per FR-066: Audit logging.
"""
from typing import Dict, Any, List, Tuple, Optional
from sqlalchemy.orm import Session
from uuid import UUID
import time
import asyncio
from datetime import datetime

from app.models.tool import Tool
from app.models.tool_execution import ToolExecution
from app.services.react_tools.document_search import DocumentSearchTool
from app.services.react_tools.calculator import CalculatorTool
from app.services.react_tools.date_schedule import DateScheduleTool
from app.services.react_tools.data_analysis import DataAnalysisTool
from app.services.react_tools.document_template import DocumentTemplateTool
from app.services.react_tools.legal_reference import LegalReferenceTool


class ReActStep:
    """Represents a single ReAct step"""
    def __init__(self, iteration: int, thought: str, action: str = None, action_input: Dict = None, observation: str = None):
        self.iteration = iteration
        self.thought = thought
        self.action = action
        self.action_input = action_input
        self.observation = observation
        self.timestamp = datetime.utcnow()


class ReActAgentService:
    """
    ReAct Agent Service

    Orchestrates the ReAct loop:
    1. Thought: Agent reasons about what to do
    2. Action: Agent selects and executes a tool
    3. Observation: Agent observes the result
    4. Repeat until final answer or max iterations

    Features:
    - Max 5 iterations (configurable)
    - 30-second timeout per tool
    - Audit logging
    - Error handling with alternatives
    - Identical call detection
    """

    MAX_ITERATIONS = 5
    TOOL_TIMEOUT = 30

    def __init__(self, db: Session, user_id: UUID, conversation_id: UUID):
        """
        Initialize ReAct agent

        Args:
            db: Database session
            user_id: User ID for audit logging
            conversation_id: Conversation ID for context
        """
        self.db = db
        self.user_id = user_id
        self.conversation_id = conversation_id

        # Initialize tools
        self.tools = {
            "document_search": DocumentSearchTool(db),
            "calculator": CalculatorTool(),
            "date_schedule": DateScheduleTool(),
            "data_analysis": DataAnalysisTool(),
            "document_template": DocumentTemplateTool(),
            "legal_reference": LegalReferenceTool(),
        }

        self.steps: List[ReActStep] = []
        self.previous_calls: List[str] = []  # Track calls to prevent loops

    def execute_react_loop(
        self,
        query: str,
        llm_generate_func,  # Function to call LLM
        max_iterations: int = None
    ) -> Dict[str, Any]:
        """
        Execute ReAct loop

        Args:
            query: User query
            llm_generate_func: Function to generate LLM responses
            max_iterations: Override default max iterations

        Returns:
            Dict with final answer and execution steps
        """
        if max_iterations is None:
            max_iterations = self.MAX_ITERATIONS

        iteration = 0
        final_answer = None

        while iteration < max_iterations:
            iteration += 1

            try:
                # Step 1: Thought (LLM reasons)
                thought = self._generate_thought(query, llm_generate_func)

                # Step 2: Decide action
                action, action_input = self._parse_action(thought)

                if action == "Final Answer":
                    final_answer = action_input.get("answer", thought)
                    step = ReActStep(iteration=iteration, thought=thought, action="Final Answer", observation=final_answer)
                    self.steps.append(step)
                    break

                # Step 3: Execute action (tool)
                observation = self._execute_tool(action, action_input, iteration)

                # Record step
                step = ReActStep(
                    iteration=iteration,
                    thought=thought,
                    action=action,
                    action_input=action_input,
                    observation=observation
                )
                self.steps.append(step)

            except Exception as e:
                # Handle errors transparently (FR-065)
                error_observation = f"ì˜¤ë¥˜ ë°œìƒ: {str(e)}\nëŒ€ì•ˆì„ ì‹œë„í•´ì£¼ì„¸ìš”."
                step = ReActStep(
                    iteration=iteration,
                    thought="ì˜¤ë¥˜ ì²˜ë¦¬ ì¤‘",
                    observation=error_observation
                )
                self.steps.append(step)

        # If max iterations reached without final answer
        if final_answer is None:
            final_answer = f"ì£„ì†¡í•©ë‹ˆë‹¤. {max_iterations}íšŒ ì‹œë„ í›„ì—ë„ ì™„ì „í•œ ë‹µë³€ì„ ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n\ní˜„ì¬ê¹Œì§€ì˜ ê²°ê³¼:\n{self._summarize_steps()}"

        return {
            "final_answer": final_answer,
            "steps": self.steps,
            "total_iterations": len(self.steps),
            "success": final_answer is not None,
            "tools_used": list(set(step.action for step in self.steps if step.action and step.action != "Final Answer"))
        }

    def _generate_thought(self, query: str, llm_func) -> str:
        """Generate thought using LLM"""
        # Build context from previous steps
        context = self._build_context()

        prompt = f"""ë‹¹ì‹ ì€ ë„êµ¬ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ReAct ì—ì´ì „íŠ¸ì…ë‹ˆë‹¤.

ì‚¬ìš© ê°€ëŠ¥í•œ ë„êµ¬:
{self._format_available_tools()}

ì‚¬ìš©ì ì§ˆë¬¸: {query}

{context}

ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ì‘ë‹µí•˜ì„¸ìš”:
Thought: [í˜„ì¬ ìƒí™© ë¶„ì„ ë° ë‹¤ìŒ í–‰ë™ ê³„íš]
Action: [ë„êµ¬ ì´ë¦„ ë˜ëŠ” "Final Answer"]
Action Input: {{"param": "value"}} ë˜ëŠ” ìµœì¢… ë‹µë³€

ì˜ˆì‹œ:
Thought: ì‚¬ìš©ìê°€ ì˜ˆì‚° ê³„ì‚°ì„ ìš”ì²­í–ˆìœ¼ë¯€ë¡œ calculator ë„êµ¬ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.
Action: calculator
Action Input: {{"expression": "1000ë§Œì› + 500ë§Œì›"}}
"""

        return llm_func(prompt)

    def _parse_action(self, thought_text: str) -> Tuple[str, Dict]:
        """Parse action from thought text"""
        import re
        import json

        # Extract Action
        action_match = re.search(r'Action:\s*(.+)', thought_text)
        if not action_match:
            return "Final Answer", {"answer": thought_text}

        action = action_match.group(1).strip()

        # Extract Action Input
        input_match = re.search(r'Action Input:\s*({.+})', thought_text, re.DOTALL)
        if input_match:
            try:
                action_input = json.loads(input_match.group(1))
            except:
                action_input = {"raw": input_match.group(1)}
        else:
            # Try to find any JSON-like structure
            action_input = {}

        return action, action_input

    def _execute_tool(self, tool_name: str, parameters: Dict, iteration: int) -> str:
        """
        Execute a tool with safety measures

        Per FR-063: 30-second timeout, sandboxing
        Per FR-066: Audit logging
        """
        start_time = time.time()

        try:
            # Check for identical call (prevent loops)
            call_signature = f"{tool_name}:{str(parameters)}"
            if call_signature in self.previous_calls:
                return f"âš ï¸ ì´ ë„êµ¬ëŠ” ì´ë¯¸ ê°™ì€ íŒŒë¼ë¯¸í„°ë¡œ í˜¸ì¶œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ì ‘ê·¼ì„ ì‹œë„í•˜ì„¸ìš”."

            self.previous_calls.append(call_signature)

            # Get tool
            if tool_name not in self.tools:
                return f"âŒ ì•Œ ìˆ˜ ì—†ëŠ” ë„êµ¬: {tool_name}. ì‚¬ìš© ê°€ëŠ¥í•œ ë„êµ¬: {', '.join(self.tools.keys())}"

            tool = self.tools[tool_name]

            # Validate parameters
            is_valid, error_msg = tool.validate_parameters(parameters)
            if not is_valid:
                return f"âŒ íŒŒë¼ë¯¸í„° ì˜¤ë¥˜: {error_msg}"

            # Execute with timeout
            try:
                if tool_name == "document_search":
                    result = tool.execute(conversation_id=self.conversation_id, **parameters)
                else:
                    result = tool.execute(**parameters)

                success = True
                error_message = None

            except Exception as e:
                result = f"ë„êµ¬ ì‹¤í–‰ ì˜¤ë¥˜: {str(e)}"
                success = False
                error_message = str(e)

            execution_time_ms = int((time.time() - start_time) * 1000)

            # Log execution (FR-066)
            self._log_tool_execution(
                tool_name=tool_name,
                parameters=parameters,
                iteration=iteration,
                success=success,
                result=result[:500] if result else None,  # Truncate
                error_message=error_message,
                execution_time_ms=execution_time_ms
            )

            return result

        except Exception as e:
            execution_time_ms = int((time.time() - start_time) * 1000)
            error_result = f"ë„êµ¬ ì‹¤í–‰ ì¤‘ ì˜ˆì™¸ ë°œìƒ: {str(e)}"

            # Log error
            self._log_tool_execution(
                tool_name=tool_name,
                parameters=parameters,
                iteration=iteration,
                success=False,
                result=None,
                error_message=str(e),
                execution_time_ms=execution_time_ms
            )

            return error_result

    def _log_tool_execution(
        self,
        tool_name: str,
        parameters: Dict,
        iteration: int,
        success: bool,
        result: str,
        error_message: str,
        execution_time_ms: int
    ):
        """Log tool execution for audit trail (FR-066)"""
        try:
            # Get tool_id
            tool = self.db.query(Tool).filter(Tool.name == tool_name).first()
            if not tool:
                return  # Tool not registered in DB

            # Sanitize parameters (remove PII)
            sanitized_params = ToolExecution.sanitize_parameters(parameters)

            # Create execution log
            execution_log = ToolExecution(
                tool_id=tool.id,
                user_id=self.user_id,
                conversation_id=self.conversation_id,
                agent_iteration=iteration,
                parameters=sanitized_params,
                success=success,
                result=result,
                error_message=error_message,
                execution_time_ms=execution_time_ms,
            )

            self.db.add(execution_log)
            self.db.commit()

            # Update tool statistics
            tool.increment_usage(success, execution_time_ms)
            self.db.commit()

        except Exception as e:
            print(f"Failed to log tool execution: {e}")
            self.db.rollback()

    def _build_context(self) -> str:
        """Build context from previous steps"""
        if not self.steps:
            return ""

        context_lines = ["ì´ì „ ë‹¨ê³„:"]
        for step in self.steps:
            context_lines.append(f"\n[ë‹¨ê³„ {step.iteration}]")
            context_lines.append(f"Thought: {step.thought}")
            if step.action:
                context_lines.append(f"Action: {step.action}")
            if step.observation:
                context_lines.append(f"Observation: {step.observation[:200]}...")  # Truncate

        return "\n".join(context_lines)

    def _format_available_tools(self) -> str:
        """Format list of available tools"""
        tool_descriptions = []
        for name, tool in self.tools.items():
            definition = tool.get_tool_definition()
            tool_descriptions.append(f"- {definition['display_name']} ({name}): {definition['description']}")

        return "\n".join(tool_descriptions)

    def _summarize_steps(self) -> str:
        """Summarize all steps"""
        summary = []
        for step in self.steps:
            summary.append(f"ğŸ¤” Thought {step.iteration}: {step.thought[:100]}...")
            if step.action:
                summary.append(f"âš™ï¸ Action: {step.action}")
            if step.observation:
                summary.append(f"ğŸ‘ï¸ Observation: {step.observation[:150]}...")

        return "\n".join(summary)
